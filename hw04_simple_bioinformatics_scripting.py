# -*- coding: utf-8 -*-
"""HW04- Simple Bioinformatics scripting

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e8qf3WMvZO3Wj0f5APpt8lWnVwoNNKs7

DNA: Counting DNA Nucleotides

Given: A DNA string s of length at most 1000 nt.
Return: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s
.
"""

dna_seq = 'AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC'

def nucleotide_count(dna_seq):
  A_count = dna_seq.count('A')
  C_count = dna_seq.count('C')
  G_count = dna_seq.count('G')
  T_count = dna_seq.count('T')
  return A_count, C_count, G_count, T_count

nucleotide_count(dna_seq)

"""RNA: Transcribing DNA into RNA

Given: A DNA string t having length at most 1000 nt.

Return: The transcribed RNA string of t.
"""

dna_seq = 'GATGGAACTTGACTACGTAAATT'

def transcribe(dna_seq):
  rna_seq = dna_seq.replace('T', 'U')
  return rna_seq

transcribe(dna_seq)

"""REVC: Complementing a Strand of DNA

Given: A DNA string s
 of length at most 1000 bp.

Return: The reverse complement sc
 of s
.
"""

dna_seq = 'AAAACCCGGT'

def complement(dna_seq):
  bp_dict = {'A':'T', 'T':'A', 'C':'G', 'G':'C'}
  rev = dna_seq[::-1]
  comp = ''
  for bp in rev:
    comp += bp_dict[bp]
  return comp

complement(dna_seq)

"""GC: Computing GC Content

Given: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).

Return: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.
"""

Rosalind_6404 = 'CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCCTCCCACTAATAATTCTGAGG'
Rosalind_5959 = 'CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCTATATCCATTTGTCAGCAGACACGC'
Rosalind_0808 = 'CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGACTGGGAACCTGCGGGCAGTAGGTGGAAT'

def gc_content(dna_seq):
  gc_content = (dna_seq.count('G') + dna_seq.count('C')) / len(dna_seq) * 100
  return gc_content

print(gc_content(Rosalind_6404))
print(gc_content(Rosalind_5959))
print(gc_content(Rosalind_0808))

"""HAMM: Counting Point Mutations

Given: Two DNA strings s
 and t
 of equal length (not exceeding 1 kbp).

Return: The Hamming distance dH(s,t)
.
"""

seq1 = 'GAGCCTACTAACGGGAT'
seq2 = 'CATCGTAATGACGGCCT'

def dH(seq1, seq2):
  count = 0
  for i in range(len(seq1)):
    if seq1[i] != seq2[i]:
      count += 1
  return count

dH(seq1, seq2)

"""PROT: Translating RNA into Protein

Given: An RNA string s
 corresponding to a strand of mRNA (of length at most 10 kbp).

Return: The protein string encoded by s
.
"""

protein_dict = {
    'GCU' : 'A', 'GCC' : 'A', 'GCA' : 'A', 'GCG' : 'A',
    'UGU' : 'C', 'UGC' : 'C',
    'GAU' : 'D', 'GAC' : 'D',
    'GAA' : 'E', 'GAG' : 'E',
    'UUU' : 'F', 'UUC' : 'F',
    'GGU' : 'G', 'GGC' : 'G', 'GGA' : 'G', 'GGG' : 'G',
    'CAU' : 'H', 'CAC' : 'H',
    'AUA' : 'I', 'AUC' : 'I', 'AUU' : 'I',
    'AAA' : 'K', 'AAG' : 'K',
    'UUA' : 'L', 'UUG' : 'L', 'CUU' : 'L', 'CUC' : 'L', 'CUA' : 'L', 'CUG' : 'L',
    'AUG' : 'M',
    'AAU' : 'N', 'AAC' : 'N',
    'CCU' : 'P', 'CCC' : 'P', 'CCA' : 'P', 'CCG' : 'P',
    'CAA' : 'Q', 'CAG' : 'Q',
    'CGU' : 'R', 'CGC' : 'R', 'CGA' : 'R', 'CGG' : 'R', 'AGA' : 'R', 'AGG' : 'R',
    'UCU' : 'S', 'UCC' : 'S', 'UCA' : 'S', 'UCG' : 'S', 'AGU' : 'S', 'AGC' : 'S',
    'ACU' : 'T', 'ACC' : 'T', 'ACA' : 'T', 'ACG' : 'T',
    'GUU' : 'V', 'GUC' : 'V', 'GUA' : 'V', 'GUG' : 'V',
    'UGG' : 'W',
    'UAU' : 'Y', 'UAC' : 'Y',
    'UAA' : '*', 'UAG' : '*', 'UGA' : '*',
}

mRNA = 'AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA'

def protein(seq):
  protein_seq = ''
  start = seq.find('AUG')
  for i in range(0, len(seq), 3):
    codon = seq[i:i+3]
    if protein_dict[codon] == '*':
      break
    protein_seq += protein_dict[codon]
  return protein_seq

protein(mRNA)

"""SUBS: Finding a Motif in DNA

Given: Two DNA strings s
 and t
 (each of length at most 1 kbp).

Return: All locations of t
 as a substring of s
.
"""

seq_s = 'GATATATGCATATACTT'
seq_t = 'ATAT'

def motif(seq_1, seq_2):
  positions = []
  for i in range(len(seq_s)):
    if seq_s[i:i+len(seq_t)] == seq_t:
      positions.append(i+1)
  return positions

motif(seq_s, seq_t)

"""PRTM: Calculating Protein Mass

Given: A protein string P
 of length at most 1000 aa.

Return: The total weight of P
. Consult the monoisotopic mass table.
"""

prot_mass_dict = {
    'A' : 71.03711,
    'C' : 103.00919,
    'D' : 115.02694,
    'E' : 129.04259,
    'F' : 147.06841,
    'G' : 57.02146,
    'H' : 137.05891,
    'I' : 113.08406,
    'K' : 128.09496,
    'L' : 113.08406,
    'M' : 131.04049,
    'N' : 114.04293,
    'P' : 97.05276,
    'Q' : 128.05858,
    'R' : 156.10111,
    'S' : 87.03203,
    'T' : 101.04768,
    'V' : 99.06841,
    'W' : 186.07931,
    'Y' : 163.06333,
}

protein = 'SKADYEK'

def protein_mass(protein):
  mass = 0
  for aa in protein:
    mass += prot_mass_dict[aa]
  return mass

protein_mass(protein)

"""REVP: Locating Restriction Sites

Given: A DNA string of length at most 1 kbp in FASTA format.

Return: The position and length of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order.
"""

Rosalind_24 = 'TCAATGCATGCGGGTCTATATGCAT'

def reverse_palindromes(seq):
  bp_dict = {'A':'T', 'T':'A', 'C':'G', 'G':'C'}
  def rev_comp(dna):
    rev = dna[::-1]
    comp = ''
    for bp in rev:
      comp += bp_dict[bp]
    return comp

  results = []

  for i in range(len(seq)):
    for length in range(4, 13):
      fragment = seq[i:i+length]
      if len(fragment) == length and fragment == rev_comp(fragment):
        results.append([i+1, length])

  return results

reverse_palindromes(Rosalind_24)

"""TRAN: Transitions and Transversions

Given: Two DNA strings s1
 and s2
 of equal length (at most 1 kbp).

Return: The transition/transversion ratio R(s1,s2)
.
"""

Rosalind_0209 = 'GCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGAAGTACGGGCATCAACCCAGTT'
Rosalind_2200 = 'TTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGCGGTACGAGTGTTCCTTTGGGT'\

def tran_ratio(seq1, seq2):
  transition = {('A','G'), ('G','A'), ('C','T'), ('T','C')}
  ts = 0
  tv = 0

  for a, b in zip(seq1, seq2):
    if a != b:
      if (a,b) in transition:
        ts += 1
      else:
        tv += 1
  return ts/tv

tran_ratio(Rosalind_0209, Rosalind_2200)

